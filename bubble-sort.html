<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Sort - AlgoMotion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .mono {
            font-family: 'Fira Code', monospace;
        }
        #animation-canvas {
            background-color: #1f2937; /* gray-800 */
            border-radius: 0.5rem;
        }
        .code-block {
            background-color: #111827; /* gray-900 */
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
            color: #d1d5db; /* gray-300 */
        }
        .code-block .comment {
            color: #6b7280; /* gray-500 */
        }
        .tab-btn.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
        }
        .control-btn {
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-weight: bold;
            color: white;
            transition: all 0.2s ease-in-out;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: translateY(0);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #sort-btn { background-image: linear-gradient(to right, #16a34a, #22c55e); }
        #pause-btn { background-image: linear-gradient(to right, #f59e0b, #facc15); }
        #reset-btn { background-image: linear-gradient(to right, #dc2626, #ef4444); }
        #backward-btn, #forward-btn { background-image: linear-gradient(to right, #3b82f6, #60a5fa); }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="container mx-auto p-4 md:p-8">
        <!-- Header -->
        <header class="flex justify-between items-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-purple-400 via-pink-500 to-red-500">
                Bubble Sort
            </h1>
            <a href="sorting-algorithms.html" class="text-purple-400 hover:text-purple-300 transition-colors duration-300 font-semibold text-lg">
                &larr; Back to Sorting Algorithms
            </a>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column: Explanation -->
            <div class="lg:col-span-1 space-y-6 text-gray-300">
                <div>
                    <h2 class="text-2xl font-bold text-white mb-3">How It Works</h2>
                    <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The algorithm gets its name because smaller elements "bubble" to the top of the list.</p>
                </div>
                <div>
                    <h2 class="text-2xl font-bold text-white mb-3">Performance</h2>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong class="text-white">Worst-case time complexity:</strong> <span class="mono text-pink-400">O(n²)</span></li>
                        <li><strong class="text-white">Average time complexity:</strong> <span class="mono text-pink-400">O(n²)</span></li>
                        <li><strong class="text-white">Best-case time complexity:</strong> <span class="mono text-pink-400">O(n)</span></li>
                        <li><strong class="text-white">Space complexity:</strong> <span class="mono text-pink-400">O(1)</span></li>
                    </ul>
                </div>
                 <div>
                    <h2 class="text-2xl font-bold text-white mb-3">Step-by-Step</h2>
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Start at the beginning of the array.</li>
                        <li>Compare the first two elements. If the first is greater than the second, swap them.</li>
                        <li>Move to the next pair of elements, compare them, and swap if needed.</li>
                        <li>Continue until the end of the array. The largest element will now be at the end.</li>
                        <li>Repeat the process for the rest of the array, excluding the already-sorted elements at the end.</li>
                    </ol>
                </div>
            </div>

            <!-- Right Column: Visualization -->
            <div class="lg:col-span-2">
                <div class="bg-gray-800 rounded-lg p-4">
                    <canvas id="animation-canvas" width="800" height="400"></canvas>
                </div>
                <!-- Controls -->
                <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
                    <div class="space-y-2">
                        <label for="array-input" class="font-semibold">Enter numbers (comma-separated):</label>
                        <input type="text" id="array-input" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500" value="8, 5, 2, 9, 3">
                    </div>
                    <div class="grid grid-cols-5 gap-2">
                         <button id="sort-btn" class="control-btn">Sort</button>
                         <button id="backward-btn" class="control-btn" disabled>&laquo; Back</button>
                         <button id="pause-btn" class="control-btn" disabled>Pause</button>
                         <button id="forward-btn" class="control-btn" disabled>Next &raquo;</button>
                         <button id="reset-btn" class="control-btn">Reset</button>
                    </div>
                </div>
                 <div class="mt-4">
                    <label for="speed-slider" class="font-semibold">Speed:</label>
                    <input type="range" id="speed-slider" min="1" max="100" value="50" class="w-full">
                </div>
            </div>
        </div>

        <!-- Code Implementation Section -->
        <div class="mt-12">
            <h2 class="text-3xl font-bold text-center mb-6">Code Implementation</h2>
            <div class="flex justify-center mb-4 border-b border-gray-700">
                <button class="tab-btn py-2 px-4 font-semibold text-gray-400 transition-colors active" data-lang="python">Python</button>
                <button class="tab-btn py-2 px-4 font-semibold text-gray-400 transition-colors" data-lang="java">Java</button>
                <button class="tab-btn py-2 px-4 font-semibold text-gray-400 transition-colors" data-lang="cpp">C++</button>
                <button class="tab-btn py-2 px-4 font-semibold text-gray-400 transition-colors" data-lang="c">C</button>
            </div>
            <div id="code-container">
                <!-- Python -->
                <div id="code-python" class="code-block mono">
<pre><code>def bubble_sort(arr):
    n = len(arr)
    <span class="comment"># Outer loop for passes</span>
    for i in range(n):
        swapped = False
        <span class="comment"># Inner loop for comparisons. The range decreases
        # with each pass as the largest elements are
        # moved to the end.</span>
        for j in range(0, n-i-1):
            <span class="comment"># Compare adjacent elements</span>
            if arr[j] > arr[j+1]:
                <span class="comment"># Swap them if they are in the wrong order</span>
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        <span class="comment"># If no swaps occurred in a pass, the array is sorted.</span>
        if not swapped:
            break
</code></pre>
                </div>
                <!-- Java -->
                <div id="code-java" class="code-block mono hidden">
<pre><code>class BubbleSort {
    void bubbleSort(int arr[]) {
        int n = arr.length;
        <span class="comment">// Outer loop for passes</span>
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            <span class="comment">// Inner loop for comparisons</span>
            for (int j = 0; j < n - i - 1; j++) {
                <span class="comment">// Compare adjacent elements</span>
                if (arr[j] > arr[j + 1]) {
                    <span class="comment">// Swap them if they are in the wrong order</span>
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            <span class="comment">// If no swaps, array is sorted</span>
            if (!swapped) break;
        }
    }
}
</code></pre>
                </div>
                <!-- C++ -->
                <div id="code-cpp" class="code-block mono hidden">
<pre><code>#include &lt;iostream&gt;
using namespace std;

void bubbleSort(int arr[], int n) {
    <span class="comment">// Outer loop for passes</span>
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;
        <span class="comment">// Inner loop for comparisons</span>
        for (int j = 0; j < n - i - 1; j++) {
            <span class="comment">// Compare adjacent elements</span>
            if (arr[j] > arr[j + 1]) {
                <span class="comment">// Swap them if they are in the wrong order</span>
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        <span class="comment">// If no swaps, array is sorted</span>
        if (!swapped) break;
    }
}
</code></pre>
                </div>
                <!-- C -->
                <div id="code-c" class="code-block mono hidden">
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

void swap(int* xp, int* yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

void bubbleSort(int arr[], int n) {
    <span class="comment">// Outer loop for passes</span>
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;
        <span class="comment">// Inner loop for comparisons</span>
        for (int j = 0; j < n - i - 1; j++) {
            <span class="comment">// Compare adjacent elements</span>
            if (arr[j] > arr[j + 1]) {
                <span class="comment">// Swap them if they are in the wrong order</span>
                swap(&arr[j], &arr[j + 1]);
                swapped = true;
            }
        }
        <span class="comment">// If no swaps, array is sorted</span>
        if (!swapped) break;
    }
}
</code></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('animation-canvas');
        const ctx = canvas.getContext('2d');
        const arrayInput = document.getElementById('array-input');
        const sortBtn = document.getElementById('sort-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const speedSlider = document.getElementById('speed-slider');
        const forwardBtn = document.getElementById('forward-btn');
        const backwardBtn = document.getElementById('backward-btn');

        // --- STATE MANAGEMENT ---
        let array = [];
        let initialArray = [];
        let animationQueue = [];
        let currentStep = 0;
        let isPaused = false;
        let isSorting = false;
        let animationFrameId;
        let statusText = "Ready to sort. Press the Sort button.";
        const defaultColor = '#6366f1'; // indigo-500
        const compareColor = '#f59e0b'; // amber-500
        const swapColor = '#ec4899';    // pink-500
        const sortedColor = '#22c55e';  // green-500

        // --- INITIALIZATION ---
        function initialize() {
            const initialValue = arrayInput.value.trim();
            if (initialValue) {
                array = initialValue.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
                initialArray = [...array];
            } else {
                array = [];
                initialArray = [];
            }
            animationQueue = [];
            currentStep = 0;
            isPaused = false;
            isSorting = false;
            statusText = "Ready to sort. Press the Sort button.";
            sortBtn.disabled = false;
            pauseBtn.disabled = true;
            pauseBtn.textContent = 'Pause';
            updateStepButtons();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            drawArray();
        }

        // --- 2D BOX DRAWING LOGIC ---
        function drawRoundedRect(x, y, width, height, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
            ctx.fill();
        }

        function drawArray(compareIndices = [], swapIndices = [], sortedIndex = -1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'white';
            ctx.font = '18px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(statusText, canvas.width / 2, 30);

            const boxSize = 60;
            const boxGap = 20;
            const boxRadius = 10;
            const totalWidth = array.length * (boxSize + boxGap) - boxGap;
            const startX = (canvas.width - totalWidth) / 2;
            const startY = canvas.height / 2;

            array.forEach((value, i) => {
                let horizontalShift = 0;
                if (compareIndices.includes(i)) {
                    const shiftAmount = 20;
                    horizontalShift = (i === compareIndices[0]) ? -shiftAmount : shiftAmount;
                }

                const x = startX + i * (boxSize + boxGap) + horizontalShift;
                let color = defaultColor;

                if (i >= array.length - sortedIndex) color = sortedColor;
                if (swapIndices.includes(i)) color = swapColor;
                if (compareIndices.includes(i)) color = compareColor;
                
                const lift = compareIndices.includes(i) ? -40 : 0;
                const currentY = startY + lift;
                
                drawRoundedRect(x, currentY, boxSize, boxSize, boxRadius, color);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, x + boxSize / 2, currentY + boxSize / 2);

                const currentAnimStep = animationQueue[currentStep];
                if (compareIndices.length === 2 && i === compareIndices[0] && currentAnimStep) {
                    const originalX = startX + i * (boxSize + boxGap);
                    const midX = originalX + boxSize + boxGap / 2;
                    const symbolY = currentY + boxSize / 2;
                    ctx.font = 'bold 30px Inter';
                    ctx.fillStyle = 'white';
                    
                    if (currentAnimStep.type === 'compare' || currentAnimStep.type === 'no_swap') {
                         const symbol = currentAnimStep.values[0] > currentAnimStep.values[1] ? '>' : '<=';
                         ctx.fillText(symbol, midX, symbolY);
                    }
                }
            });
        }

        // --- ALGORITHM LOGIC ---
        function generateBubbleSortQueue() {
            animationQueue = [];
            let tempArray = [...array];
            let n = tempArray.length;
            for (let i = 0; i < n; i++) {
                let swappedInPass = false;
                for (let j = 0; j < n - i - 1; j++) {
                    animationQueue.push({ type: 'compare', indices: [j, j + 1], sortedCount: i, values: [tempArray[j], tempArray[j+1]] });
                    if (tempArray[j] > tempArray[j + 1]) {
                        animationQueue.push({ type: 'swap', indices: [j, j + 1], sortedCount: i, values: [tempArray[j], tempArray[j+1]] });
                        [tempArray[j], tempArray[j + 1]] = [tempArray[j + 1], tempArray[j]];
                        swappedInPass = true;
                    } else {
                        animationQueue.push({ type: 'no_swap', indices: [j, j + 1], sortedCount: i, values: [tempArray[j], tempArray[j+1]] });
                    }
                }
                animationQueue.push({ type: 'pass_done', sortedCount: i + 1, value: tempArray[n - 1 - i] });
                if (!swappedInPass) {
                    animationQueue.push({ type: 'early_exit' });
                    break;
                }
            }
            animationQueue.push({ type: 'done' });
        }
        
        // --- ANIMATION & STEP LOGIC ---
        function executeStep(stepIndex) {
            const step = animationQueue[stepIndex];
            if (!step) return;

            if (step.type === 'compare') {
                statusText = `Comparing elements ${step.values[0]} and ${step.values[1]}.`;
                drawArray(step.indices, [], step.sortedCount);
            } else if (step.type === 'no_swap') {
                statusText = `Since ${step.values[0]} <= ${step.values[1]}, no swap is needed.`;
                drawArray(step.indices, [], step.sortedCount);
            } else if (step.type === 'swap') {
                statusText = `Since ${step.values[0]} > ${step.values[1]}, we will swap their positions.`;
                drawArray([], step.indices, step.sortedCount);
            } else if (step.type === 'pass_done') {
                statusText = `End of pass. ${step.value} is now in its correct sorted position.`;
                drawArray([], [], step.sortedCount);
            } else if (step.type === 'early_exit' || step.type === 'done') {
                statusText = "The array is now fully sorted!";
                drawArray([], [], array.length);
            }
        }

        function animate() {
            if (isPaused || currentStep >= animationQueue.length) {
                if (currentStep >= animationQueue.length -1) {
                    isSorting = false;
                    sortBtn.disabled = false;
                    pauseBtn.disabled = true;
                    updateStepButtons();
                }
                return;
            }

            // Perform the action for the current step
            const step = animationQueue[currentStep];
            if (step.type === 'swap') {
                const [i, j] = step.indices;
                [array[i], array[j]] = [array[j], array[i]];
            }
            executeStep(currentStep);
            
            let delay = (151 - speedSlider.value) * 12;
            if (step.type === 'compare') delay += 500; 
            if (step.type === 'no_swap' || step.type === 'swap') delay += 400;

            currentStep++;
            
            setTimeout(() => {
                animationFrameId = requestAnimationFrame(animate);
            }, delay);
        }

        function manualStep(direction) {
            if (!isPaused) return;

            const newStep = currentStep + direction;
            if (newStep < 0 || newStep >= animationQueue.length) return;
            
            currentStep = newStep;

            // Rebuild the array state from the beginning up to the new step
            array = [...initialArray];
            for (let i = 0; i < currentStep; i++) {
                const step = animationQueue[i];
                if (step.type === 'swap') {
                    const [x, y] = step.indices;
                    [array[x], array[y]] = [array[y], array[x]];
                }
            }
            
            executeStep(currentStep);
            updateStepButtons();
        }

        function updateStepButtons() {
            if (isPaused) {
                backwardBtn.disabled = currentStep <= 0;
                forwardBtn.disabled = currentStep >= animationQueue.length - 1;
            } else {
                backwardBtn.disabled = true;
                forwardBtn.disabled = true;
            }
        }

        // --- EVENT LISTENERS ---
        sortBtn.addEventListener('click', () => {
            if (isSorting) return;
            initialize();
            if (array.length === 0) return;
            isSorting = true;
            sortBtn.disabled = true;
            pauseBtn.disabled = false;
            updateStepButtons();
            generateBubbleSortQueue();
            animate();
        });

        pauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
            updateStepButtons();
            if (!isPaused) {
                animate();
            }
        });

        resetBtn.addEventListener('click', initialize);
        arrayInput.addEventListener('change', initialize);
        forwardBtn.addEventListener('click', () => manualStep(1));
        backwardBtn.addEventListener('click', () => manualStep(-1));

        // --- CODE TABS ---
        const tabButtons = document.querySelectorAll('.tab-btn');
        const codeBlocks = document.querySelectorAll('.code-block');
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const lang = button.dataset.lang;
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                codeBlocks.forEach(block => {
                    if (block.id === `code-${lang}`) {
                        block.classList.remove('hidden');
                    } else {
                        block.classList.add('hidden');
                    }
                });
            });
        });

        // --- INITIAL CALL ---
        window.onload = () => {
            const container = document.querySelector('.lg\\:col-span-2');
            if (container) {
                canvas.width = container.clientWidth - 32;
            }
            initialize();
        };
        window.onresize = () => {
             const container = document.querySelector('.lg\\:col-span-2');
            if (container) {
                canvas.width = container.clientWidth - 32;
            }
            initialize();
        };
    </script>
</body>
</html>
